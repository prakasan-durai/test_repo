# Orb 'cyberark/conjur-circleci-orb@0.0.1' resolved to 'cyberark/conjur-circleci-orb@0.0.1'
version: 2
jobs:
  run-job:
    docker:
    - image: cimg/base:current
    steps:
    - run:
        command: echo Hello Earth
    - run:
        command: echo Goodbye Earth
    - run:
        command: "#!/bin/bash\n# Conjur Secret Retrieval for CirclCI Orb conjur-circleci\n\nfunction main() {\n  check_parameter \"CONJUR_APPLIANCE_URL\" \"$PARAM_APPLIANCE_URL\"\n  check_parameter \"CONJUR_ACCOUNT\" \"$PARAM_ACCOUNT\"\n  check_parameter \"CONJUR_SERVICE_ID\" \"$PARAM_SERVICE_ID\"\n  check_parameter \"CONJUR_SECRETS_ID\" \"$PARAM_SECRETS_ID\"\n\n  CONJUR_SECRETS_ID=\"${PARAM_SECRETS_ID}\"\n  CONJUR_CERTIFICATE=\"${PARAM_CERTIFICATE}\"\n  CONJUR_APPLIANCE_URL=$(eval echo \"${PARAM_APPLIANCE_URL}\")\n  CONJUR_ACCOUNT=$(eval echo \"${PARAM_ACCOUNT}\")\n  CONJUR_SERVICE_ID=$(eval echo \"${PARAM_SERVICE_ID}\")\n\n  if [ -z \"${CIRCLE_OIDC_TOKEN_V2}\" ]; then\n    echo \"OIDC Token cannot be found. A CircleCI context must be specified.\"\n    exit 1\n  fi\n\n  echo \"${CONJUR_CERTIFICATE}\" > conjur_\"${CONJUR_ACCOUNT}\".pem\n  echo \"::debug Authenticate via Authn-JWT\"\n\n  array_secrets\n  InstallJq\n  authenticate\n  fetch_secret\n}\n\nfunction check_parameter() {\n  local param_name=\"$1\"\n  local param_value=\"$2\"\n  if [ -z \"$param_value\" ]; then\n    echo \"The $param_name is not found. Please add the $param_name before continuing.\"\n    exit 1\n  fi\n}\n\nfunction urlencode() {\n    old_lc_collate=$LC_COLLATE\n    LC_COLLATE=C\n\n    local length=\"${#1}\"\n    for (( i = 0; i < length; i++ )); do\n        local c=\"${1:i:1}\"\n        case $c in\n            [a-zA-Z0-9.~_-]) printf \"%s\" \"$c\" ;;\n            ' ') printf \"%%20\" ;;\n            *) printf '%%%02X' \"'$c\" ;;\n        esac\n    done\n\n    LC_COLLATE=$old_lc_collate\n}\n\nfunction array_secrets() {\n    IFS=';'\n    read -ra SECRETS <<< \"${CONJUR_SECRETS_ID}\"\n}\n\nfunction InstallJq() {\n    if command -v curl >/dev/null 2>&1 && ! command -v jq >/dev/null 2>&1; then\n        uname -a | grep Darwin > /dev/null 2>&1 && JQ_VERSION=jq-osx-amd64 || JQ_VERSION=jq-linux32\n        echo \"PATH :: $JQ_PATH\"\n        curl -Ls -o \"$JQ_PATH\" https://github.com/stedolan/jq/releases/download/jq-1.6/\"${JQ_VERSION}\"\n        chmod +x \"$JQ_PATH\"\n        command -v jq >/dev/null 2>&1\n        return $?\n    else\n        command -v curl >/dev/null 2>&1 || { echo >&2 \"CONJUR ORB ERROR: CURL is required. Please install.\"; exit 1; }\n        command -v jq >/dev/null 2>&1 || { echo >&2 \"CONJUR ORB ERROR: JQ is required. Please install\"; exit 1; }\n        return $?\n    fi\n}\n\nfunction network_client() {\n  local method=\"$1\"\n  local url=\"$2\"\n  local data=\"\"\n  local response\n\n  declare -a common_curl_options=()\n  \n  if [[ -n \"${CONJUR_CERTIFICATE}\" ]]; then\n    common_curl_options+=(\"--cacert\" \"conjur_${CONJUR_ACCOUNT}.pem\")\n  fi\n\n  case \"$method\" in\n    \"POST\")\n      data=\"$3\"\n      common_curl_options+=(\"--request\" \"$method\" \"$url\" \"--header\" 'Content-Type: application/x-www-form-urlencoded' \"--header\" \"Accept-Encoding: base64\" \"--data-urlencode\" \"$data\")\n      ;;\n    \"GET\")\n      common_curl_options+=(\"$url\" \"--header\" \"Authorization: Token token=\\\"$token\\\"\")\n      ;;\n    *)\n      echo \"Unsupported HTTP method: $method\"\n      exit 1\n      ;;\n  esac\n\n  response=$(curl \"${common_curl_options[@]}\")\n  \n  if [ \"$method\" == \"POST\" ]; then\n    token=\"$response\"\n  else\n    result=\"$response\"\n  fi\n}\n\nfunction authenticate() {\n  local jwt_token=\"${CIRCLE_OIDC_TOKEN_V2}\"\n\n  network_client \"POST\" \"${CONJUR_APPLIANCE_URL}/authn-jwt/${CONJUR_SERVICE_ID}/${CONJUR_ACCOUNT}/authenticate\" \"jwt=$jwt_token\"\n\n  if [ -z \"${token}\" ]; then\n    echo \"Authentication Failed.\"\n    exit 1\n  else  \n    echo \"Authentication Successful.\"\n  fi\n}\n\nfunction multiple_secrets_fetch() {\n  network_client \"GET\" \"${CONJUR_APPLIANCE_URL}/secrets?variable_ids=${secrets_string}\"\n  secretsVal=$(jq -r 'to_entries | map(\"\\(.key)=\\(.value)\") | join(\",\")' <<< \"${result}\")\n}\n\nfunction single_secret_fetch() {\n  local flag=false\n  local err_msg=\"Secret(s) are empty or not found :: \"\n\n  for secretId in \"${!secretMulti[@]}\"; do\n    network_client \"GET\" \"${CONJUR_APPLIANCE_URL}/secrets/${CONJUR_ACCOUNT}/variable/$secretId\"\n\n    local secretVal=\"${result}\"\n\n    if [[ \"${secretVal}\" == \"Malformed authorization token\" ]]; then\n      echo \"::error::Malformed authorization token. Please check your Conjur account, username, and service id. If using authn-jwt, check your Host ID annotations are correct.\"\n      exit 1\n    elif [[ \"${secretVal}\" == *\"is empty or not found\"* ]]; then\n      flag=true\n      err_msg+=\"${secretId}, \"\n    else\n      echo \"As the job will be marked as unsuccessful, the environment variable for secrets found is not set.\"\n    fi\n  done\n\n  if $flag; then\n    echo \"${err_msg}\"\n    exit 1\n  fi\n}\n\nfunction set_environment_var(){\n  local multiple_secrets=\"${secretsVal[0]}\" \n  local secret_key\n\n  IFS=','\n  read -ra comma_split <<< \"$multiple_secrets\"\n\n  for element in \"${comma_split[@]}\"; do\n    IFS='='\n    read -ra equal_split <<< \"$element\"\n\n    local key=\"${equal_split[0]}\"\n    local value=\"${equal_split[1]}\"\n\n    IFS=':'\n    read -ra colon_split <<< \"$key\" \n    secret_key=$(urlencode \"${colon_split[${#colon_split[@]}-1]}\")\n\n    if [ \"${PARAM_INTEGR}\" == \"true\" ]; then\n      echo \"Secret fetched successfully. fetched :: $value\"\n    else  \n      echo \"export ${secretMulti[$secret_key]}='${value}'\" >> \"${BASH_ENV}\"\n      echo \"Secret fetched successfully.  Environment variable ${secretMulti[$secret_key]} set. \"\n    fi\n    IFS=','\n  done\n  IFS=$' \\t\\n'\n}\n\nfunction fetch_secret() {\n  declare -A secretMulti\n  local secretId\n  local secrets_string\n\n  for secret in \"${SECRETS[@]}\"; do\n    IFS='|'\n    read -ra METADATA <<< \"$secret\" \n\n    if [[ \"${#METADATA[@]}\" == 2 ]]; then\n      secretId=$(urlencode \"${METADATA[0]}\")\n      envVar=${METADATA[1]^^}\n    else\n      secretId=${METADATA[0]}\n      IFS='/'\n      read -ra SPLITSECRET <<< \"$secretId\" \n      local arrLength=${#SPLITSECRET[@]} \n      local lastIndex=$((arrLength-1)) \n      local envVar=${SPLITSECRET[$lastIndex]^^}\n      secretId=$(urlencode \"${METADATA[0]}\")\n    fi\n    secretMulti[\"$secretId\"]=\"$envVar\" \n  done \n\n  #### Construct comma-delimited resource IDs of the variables.\n  local secretsPath=()\n  for key in \"${!secretMulti[@]}\"; do \n    secretsPath+=(\"${CONJUR_ACCOUNT}\"\":variable:\"\"$key\")\n  done\n\n  ### Array of secretsPath into comma separated string\n  secrets_string=$(IFS=,; echo \"${secretsPath[*]}\")\n\n  multiple_secrets_fetch\n  #### If Batch retrieval of secrets not found \n  if [[ \"${secretVal}\" == \"Malformed authorization token\" ]]; then\n      echo \"::error::Malformed authorization token. Please check your Conjur account, username, and service id. If using authn-jwt, check your Host ID annotations are correct.\"\n      exit 1\n  elif [[ \"${secretsVal}\" == *\"is empty or not found\"* ]]; then\n    echo \"${secretsVal}. Batch retrieval failed, falling to single secret fetch.\"\n    single_secret_fetch\n  else\n    echo \"Batch retrieval of secrets succeeded.\"  \n    ######set environment variable \n    set_environment_var\n  fi\n}\n\nTEST_MODE=$(eval echo \"${PARAM_TEST_MODE}\")\n\nif [ \"$TEST_MODE\" == \"false\" ]; then\n  main \"$@\"\nfi"
        environment:
          PARAM_ACCOUNT: ${CONJUR_ACCOUNT}
          PARAM_APPLIANCE_URL: ${CONJUR_APPLIANCE_URL}
          PARAM_CERTIFICATE: ''
          PARAM_SECRETS_ID: data/circleci/apps/safe/secret2|sql_username;data/circleci/apps/safe/secret1;
          PARAM_SERVICE_ID: ${CONJUR_SERVICE_ID}
          PARAM_TEST_MODE: 'false'
        name: Fetch Secret
workflows:
  use-my-orb:
    jobs:
    - run-job
  version: 2
